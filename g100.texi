\input texinfo
@comment             **********************************************************
@setfilename         g100
@settitle            The Guile 100 Programs Project
@comment
@set utfversion      0.3
@set utfversiondate  Mar 25, 2013
@comment
@comment             This is a Texinfo file.  To convert it to Info hypertext
@comment             format, you will need the `makeinfo' program from the GNU
@comment             Texinfo package.  To produce a PDF, use `texi2pdf'. 
@comment             
@comment             
@comment             **********************************************************

@comment HISTORY:
@comment
@comment * Mar 11, 2013: initial commit.

@dircategory The Algorithmic Language Scheme
@direntry
* G100: (g100). The Guile 100 Programs Project
@end direntry

@macro newterm{term}
@cindex \term\
@dfn{\term\}
@end macro

@c @setchapternewpage odd
@setshortcontentsaftertitlepage

@titlepage
@title  The Guile 100 Programs Project
@sp 0.2
@subtitle @value{utfversion} - @value{utfversiondate}
@author Edited by Michael Gran

@page
@vskip 0pt plus 1filll
@noindent
@copyright{} 2013 by Michael Gran

@sp 0.5
@noindent
100 Guile Programs

@noindent
This work is licensed under GFDL 1.3+@*
(@url{http://www.gnu.org/licenses/fdl.html, GFDL 1.3+}).

@sp 0.5
@noindent
A Lonely Cactus Production@*
Los Angeles, California 


@end titlepage
@everyheading @| @| @thispage

@c to suppress the black boxes after overfull lines:
@finalout

@node Top, Preface, (dir), (dir)

@ifinfo

@heading The Guile 100 Programs Project

@noindent
Edited by Michael Gran@*
@copyright{} 2013 Michael Gran

@noindent
Version @value{utfversion} (@value{utfversiondate})

@end ifinfo

@ifhtml

@heading The Guile 100 Programs Project

@noindent
Version @value{utfversion} (@value{utfversiondate})

This online resource is a collection of sample programs written in GNU
Guile, an implementation of the Scheme language.

@end ifhtml

@menu
* Preface::
* Acknowledgments::
* Theme 1::
* References::
* List of Exercises::
* List of Figures::
* Index::

@detailmenu
 --- The Detailed Node Listing ---

Theme 1: ``/bin''

* Problem 1::                   echo and cat
* Problem 2::                   ls
* Problem 3::                   LZW Compression

@end detailmenu
@end menu

@node    Preface, Acknowledgments, Top, Top
@unnumbered Preface

This book aspires to be a useful set of examples about how one might
use @acronym{GNU} Guile. 

One of the interesting things about the Scheme community is that they
are perhaps @emph{too clever}.  The depth and complexity of their
thinking about computer languages is intense and wonderful.

And yet, some times you just want to do something mundane.  Where are
the resources for how to use Scheme -- and specifically Guile -- for
quotidian tasks?

Well, this document will be it, if all goes according to plan.

@node       Acknowledgments, Theme 1, Preface, Top
@unnumbered Acknowledgments

We would like to thank the many people who have helped us develop this book.
@itemize
Chris K Jester-Young contributed the original version of the @command{echo}
and @command{cat} scripts for Problem 1.
@end itemize

@node    Theme 1, References, Acknowledgments, Top
@chapter Theme 1: ``/bin''

Every project has to start somewhere, so let us begin at the
beginning.

Guile can be used as a scripting language.  Programs can be written as
plain text files, and then run from the command line by using the
Guile interpreter.  As such, most scripts run on Unix-like shells will
begin with a sha-bang @code{#!} invocation.  And most scripts must
start off doing the same chores: parsing the command line, acting on
the options, and finding the files whose names appeared in the
command-line arguments.

To introduce these mundane concepts, our first theme is @emph{/bin}, e.g.
re-implementing some common Unix tools.  This will get us warmed up.

These examples should demonstrate
@itemize
@item
How to set up the sha-bang invocation for Guile scripts run from Unix
shells.
@item
How to handle command line arguments
@item
How to map file names given as command line arguments to their files
@item
How to search for files and directories
@item
How to open files, both as binary data and as encoded text data
@end itemize

And so, without further ado, here is the first problem.

@menu
* Problem 1::                   echo and cat
* Problem 2::                   ls
* Problem 3::                   LZW Compression
@end menu

@node    Problem 1, Problem 2, Theme 1, Theme 1
@section Problem 1: Echo and Cat

In this problem, two venerable Unix commands are re-implemented in
Scheme: @command{echo} and @command{cat}.  @command{echo} prints out
the command-line arguments, and @command{cat} prints a file to the
terminal.

@subsection The Requirements for `echo' and `cat'

In this problem, like in many of the problems, we'll lay out the
requirements for a program, and then see how our volunteer implemented
the requirements.  For the purpose of this exercise, the requirements
for @command{echo} and @command{cat} with be drawn from the Posix
standard@footnote{@ref{IEEE 2004}}, with a couple of minor
modifications.

@heading Echo

The @command{echo} script writes its arguments to the standard output,
followed by a <newline>.  If there are no arguments, it just prints a
<newline>.

@command{echo} has no command-line options.  Even @option{--help} and
@option{--version} are not treated as command-line options.

If any of the arguments contain the backslash character (@code{\}),
the argument is modified.  Backslash introduces an escape.  These
escapes are parsed from logical left to right.

@table @code
@item \a
Write an <alert> in place of @code{\a}.
@item \b
Write a <backspace> in place of @code{\b}.
@item \c
Suppress the <newline> that would otherwise be written after the
command-line arguments.  The @code{\c} is not written, any remaining
characters in this argument are not written, and any remaining
arguments are not written.
@item \f
Write a <form-feed> in place of @code{\f}.
@item \n
Write a <newline> in place of @code{\n}.
@item \r
Write a <carriage-return> in place of @code{\r}.
@item \t
Write a <tab> in place of @code{\t}
@item \v
Write a <vertical-tab> in place of @code{\v}.
@item \\
Write a single backslash character in place of the pair of backslash characters.
@item \0@i{num}
Write an 8-bit character corresponding to @i{num}, an octal number
between octal 0 and octal 377 (decimal 255) inclusive.
@end table

A backslash at the end of a command line argument will not be escaped.
The backslash will be written.  However, the exit value will be 1 in
this case.

A backslash followed by any other character not listed in the table,
will will not be escaped.  The backslash will be written, and the
character that follows it will be written.  However, in this
case, the exit value will be 1.

For the octal escape @code{\0}, it is important to note that this
value is not an ISO-8859-x position or a Unicode code point, but,
rather a raw 8-bit byte to be sent unencoded to the standard output.
It is up to the operator, not @command{echo}, to ensure that a
character sequence that is valid for the environments locale is being
sent.

If a @code{\0} escape is present, but is not followed by an
number, the raw byte zero is written.

If a @code{\0} escape is present and is followed by an octal
number of greater than 3 digits, only the first 3 digits will be
interpreted as being part of the escape.

If a @code{\0} escape is present and its octal value is greater than
377, print nothing. In this case, the exit value will be 1.

An octal escape may not have unnecessary initial zeros.  For example
@itemize
@item
@code{\01} should output raw byte 1
@item 
@code{\001} should output raw byte zero followed by the string ``01''
@item
@code{\0001} should output raw byte zero followed by the string ``001''
@end itemize

The digits 8 and 9 are not part of an octal escape.  For example, the
string @code{\018} shall be output as the raw byte 1 followed by the
character for the numeral 8.

Remember that command-line arguments and file names may contain any
character allowed by the current locale.

In all other cases, the exit value will be zero.

@heading Cat

@command{cat} [OPTION]... [FILE]...

@command{cat} concatenates files or standard input and prints it to
the standard output.

This version of @command{cat} supports three command-line options,
each with a short and a long form.
@table @option
@item -u --unbuffered
Do no buffering.  Write bytes from the input to the standard output
without delay as each character is read.
@item -h --help
Print out command help.
@item -v --version
Print out the program name and version number.
@end table

After the command-line options, a list of file names is expected.  The
contents of the files are printed to standard output.  No character
encoding or decoding of the contents of the files should be performed:
they should be transmitted unmodified.

If the special file name @file{-} (hyphen) is given, at that point the
contents of the standard input will be transmitted to the standard
output.

If one of the files does not exist, or if it cannot be opened, the
program will print a descriptive error message to the standard error
and will return the exit code 1.

Otherwise, the exit code is zero.

@heading Rules and Suggestions for the Volunteer

For this exercise, the volunteer was requested to use only Guile's
library functions.  No external libraries were allowed.

The volunteer was also requested to attempt to use one of Guile's 
two sets of functions to help parse command line
options: the @code{ice-9 getopt-long} module and the @code{srfi
srfi-37} module.  As you shall see, the volunteer did use manage to
use @code{ice-9 getopt-long} for @command{cat}.

@subsection An Implementation of `echo' and `cat'

Chris K Jester-Young was the volunteer for this section, and here are
his solutions, with some annotations by the editor.

@heading `cat'

First we have @command{cat}.  One interesting thing to note in this
example is the use of @code{catch} to catch system errors that may
arise if files do not exist or cannot be opened.

@page
@verbatiminclude code/cat.scm
@page

@heading `echo'

Next up is @command{echo}. 

@page
@verbatiminclude code/echo.scm
@page

@node    Problem 2, Problem 3, Problem 1, Theme 1
@section Problem 2: `ls'

In this problem, we investigate the most famous Unix command of all
time: @command{ls}.  @command{ls} lists files or directories, and
displays their properties.

However, @command{ls} has accumulated dozens of options over the past
decades.  Implementing a feature-complete @command{ls} would takes
weeks or months of work.  So, for this week's problem, we are going to
constrain ourselves to the most important command-line options.

The command @command{ls} lists information about files, directories,
and the contents of directories.  Basically, for this challenge, the
script should operate like a limited functionality version of Posix
@command{ls}.

The script need only recognize a limited set of command-line options:
@itemize
@item
@option{-a} - display all matching files, including those whose name
begins with a period
@item
@option{-l} - use the long output format
@item
@option{-R} - recursively descend into subdirectories
@end itemize
Any other command-line arguments that begin with a hyphen should cause
an ``invalid option'' error, and the program will be terminated with a
non-zero exit code.

The command-line option @option{-R} will recursively print the
contents of any subdirectory encountered.  When this option is
requested, the script must check for infinite loops: it should error
when it enters a subdirectory whose contents have already been listed,
and a non-zero exit value should be returned.

The command-line option @option{-l} has two effects.  One, information
about the files will be printed in the long format.  Two, when given a
symbolic link to a directory, the command will print information about
the symbolic link itself and not the file or directory to which it
points.

@heading Operands

If a command-line argument does not begin with a hyphen, it is treated
as an operand.

When called without operands, the contents of the current directory
are printed.

Operands must be either the names of files, directories, or symbolic
links.  When an operand that is not one of the above is encountered,
the script should print a descriptive error and exit with a non-zero
return code.

If an operand is a file, @command{ls} will print the name of the file.
If an operand is a symbolic link to a file, the command will print the
name of the link.  If an operand is a directory, @command{ls} will
print out the contents of that directory.  If an operand is a symbolic
link to a directory, @command{ls} will print the contents of that
directory, unless the @option{-l} is given.

When printing the contents of a directory, files and directories
that begin with <period> are usually not printed.  If the command-line
option @option{-a} is given, files and directories that begin with
<period> are printed.

@heading Output

There are two output formats: the default format and the long format.

Within each directory, the files are sorted in case-insensitive
alphabetical order according to the current locale.

In the default format, the filenames are output one per line.  You can
print them out in a columnar format if you like, though.

In the long format, the file information will be printed as follows

The first character will be `d' for directory, `-' for
regular file, `b' for block special file, `l' for symbolic link, `c'
for character special file, and `p' for fifo.

The second character will be `r' if the file or directory is readable
by the owner or `-' if it is not.

The third character will be `w' if the file or directory is writable
by the owner or `-' if it is not.

The fourth character will be `S' if the file is not executable and the
set-user-ID mode is set, `s' if the file is executable and the
set-user-ID mode is set, `x' if the file is executable or the
directory is searchable by the owner, or `-' otherwise.

The fifth character will be `r' if the file or directory is readable
by the group or `-' if it is not.

The sixth character will be `w' if the file or directory is writable
by the group or `-' if it is not.

The seventh character will be `S' if the file is not executable and
the set-group-ID mode is set, `s' if the file is executable and the
set-group-ID mode is set, `x' if the file is exectuable or the
directory is searchable by members of this group, or `-' otherwise.

The eighth character will be `r' if the file or directory is readable
by others or `-' otherwise.

The ninth character will be `w' if the file or directory is writable
by others or `-' otherwise.

The tenth character will be `T' if the file is a directory and the
search permission is not granted to others and the restricted
deletion flag is set, `t' if the file is a directory and the search
permission is granted to others and the restricted deletion flag is
set, `x' if the file is executable or the directory is searchable by
others, or `-' otherwise.

The eleventh character is a <space>.

The remaining elements of the line are ``<link count> <owner name>
<group name> <file size> <date and time> <pathname>''

The link count for a directory is the number of immediate
subdirectories it has plus one for itself plus one for its parent.
The link count for a file is one.

The file size is in bytes.

The date and time is in ``month day hour:sec'' format if the file has
been modified in the last six months, or ``month day year'' format
otherwise.

The pathname for links is in the format ``<link name> -> <path to
linked file or directory>''

The exit code should be zero except in those error cases described
above.

For more information about @command{ls}, you can consult The Open
Group Base Specifications Issue 6, or the documentation of any BSD or
GNU version of @command{ls}. 

@heading Rules and Suggestions for the Volunteer

@emph{It is unknown if Guile has sufficient functionality to
actually query all the information requried for the long format.  It
is up to the volunteer to discover this.}

For this exercise, only Guile's library functions can be used.  No
external libraries are allowed.

Note that there are Scheme versions of @command{ls} that exist.
Copying them is considered cheating.

Note that Guile has two sets of functions to help parse command line
options: the @code{ice-9 getopt-long} module and the @code{srfi
srfi-37} module.  You should use one of them.

@node    Problem 3,  , Problem 2, Theme 1
@section Problem 3: LZW Compression

Lempel-Ziv-Welch compression is the basis of both the UNIX Compress
program and of GIF encoding.  Today's challenge has two parts.
@itemize
@item
Write `compress' and `uncompress' procedures for LZW compression.
@item
Use them to make `compress' and `uncompress' scripts.
@end itemize

@subsection The Requirements for Compression Procedures and Scripts

First up are the compression procedures.  Good old LZW compressions: a
nice problem in every CompSci's undergraduate classes.

@heading @code{lzw-compress} and @code{lzw-uncompress}

@deffn {Guile Procedure} lzw-compress input-bv #:key table-size dictionary
This procedure should take a bytevector presumed to contain 8-bit
unsigned integers, and it should return a bytevector containing 16-bit
unsigned integers in little-endian format.  

@var{input-bv} is the input bytevector.

@var{table-size} is an optional parameter that indicates the maximum
number of entries in the dictionary.  This parameter is limited to the
range 258 - 65536.  The default value of @var{table-size} is 65536.

@var{dictionary} is an optional parameter that modifies the output.
When true, the procedure should return both the output 16-bit
bytevector as well as the dictionary or hash table created by the
compression routine.  Since the formation of the dictionary is up to
the implementer, the output format of the dictionary is unspecified.
@end deffn

Probably the best writup on LZW compression is the one by Mark Nelson
over at @uref{http://marknelson.us/2011/11/08/lzw-revisited/}. Refer
to that article for details on LZW compression.

As is common, the first 256 entries in the dictionary -- entries #0 to
#255 -- are initialized to 0 to 255.  Entry #256 is not to be
used.  Entries #257 to #(table-size - 1) will contain the multi-byte
entries in the dictionary.

@deffn {Guile Procedure} lzw-uncompress input-bv #:key table-size dictionary
Similarly, this procedure takes @var{input-bv} the bytevector created
by @code{compress} and an optional table size and returns the
8-bit unsigned bytevector of uncompressed data.  @var{dictionary},
when true, causes the procedure to also return its dictionary or hash
table.
@end deffn

@heading The `compress' and `uncompress' scripts

Once the procedures are working, it is a simple task to write scripts
that use them.  So we'll write scripts that are simplified versions
Unix commands `compress' and `uncompress'.  These scripts will
manipulate files with the following format.

Each file will begin with a 3 byte header.
@itemize
@item
Byte 1: @code{#x1F}
@item
Byte 2: @code{#x9D}
@item
Byte 3: Dictionary size, given as an 8-bit unsigned number between 9
and 16 inclusive.  The number indicates a dictionary size from between
2^9 and 2^16.
@end itemize

The rest of the file is the LZW-compressed 16-bit binary data stored
in little-endian format.

(Note that this may not be compatible with your operating system's
version of @command{compress}.  The @command{compress} file format is
not 100% consistent across platforms.)

@example
compress [-v] [-b bits] [name ...]
@end example

For each filename, @command{compress}, will create a LZW-compressed
version of an input file.  The compressed file will have the same
filename as the input file with the ".Z" extension appended to it.  If
the compression is successful and the output file is successfully
written, the input file will be deleted.

If no filenames are given, @command{compress} will take the contents
of stdin and send the compressed data to stdout.

The optional @option{-b} @code{bits} parameter will indicate the
maximum size of the dictionary.  If @code{bits} is given, it must be between
9 and 16, indicating maximum dictionary sizes of @code{2^bits}.

If the optional @option{-v} parameter is given, the script should
print to stdout the compression ratio for each file processed.  If no
file was specified and this program is thus compressing stdin to
stdout, this flag is ignored.

Compress should fail with appropriate error messages if any of the
following problems occur 

@itemize
@item
The command-line has unknown options or is otherwise incorrect
@item
The command line argument after a @option{-b} is out of range, non-numeric,
or missing.
@item
The file associated with an input filename does not exist or is
unreadable
@item
An input filename has a ".Z" suffix
@item
Writing the output file would overwrite a file that already exists
@item
Writing to disk fails for any reason
@item
Erasing the input file on completion fails for any reason
@end itemize

If an error occurs, the script should return the error code 1.
Otherwise it returns the error code 0.

@example
uncompress [-v] [name ...]
@end example

@command{uncompress} will create an uncompressed version of a file
generated by @command{compress}.  The uncompressed file with have the
same filename as the input file with the ".Z" extension removed.  If
the uncompression is successful and the output file is successfully
written, the input file will be deleted.

Also, like @command{compress}, if no filenames are given,
@command{uncompress} takes the contents of stdin and uncompresses them
to stdout.

If the optional @option{-v} parameter is given, the script should
print to stdout the compression ratio for each file processed.  If no
file was specified and thus this program is compressing stdin to
stdout, this flag is ignored.

Uncompress should fail with appropriate error messages if any of the
following problems occur

@itemize
@item
The command-line has unknown options or is otherwise incorrect
@item
The file header is incorrect
@item
The bits parameter in the file header is out of range
@item
The file associated with the input filename does not exist or is
unreadable
@item
The input compressed data is incorrect or corrupt, which can be
detected by receiving an index that is not yet in the dictionary, or
if an index value exceeds the number of entries in the dictionary as
specified in the header, or if the last entry in the file not a
complete 16-bit integer
@item
The input file does not end in ".Z"
@item
The output file would overwrite a file that already exists
@item
Writing to disk fails for any reason.
@item
Erasing the input file on completion fails for any reason
@end itemize

If an error occurs, the script should return the error code 1.
Otherwise it returns the error code 0.

@heading Rules and Suggestions for the Volunteer

For this exercise, the volunteer is requested to use only Guile's
library functions.  No external libraries are allowed.

The volunteer is also requested to attempt to use one of Guile's 
two sets of functions to help parse command line
options: the @code{ice-9 getopt-long} module and the @code{srfi
srfi-37} module.


@node    References, List of Exercises, Theme 1, Top
@unnumbered References

@anchor{Allen 1978}
Allen, John.  1978.  @cite{Anatomy of Lisp}. New York: McGraw-Hill.

@anchor{ANSI 1994}
@acronym{ANSI} X3.226-1994. @cite{American National Standard for Information
Systems@/---Programming Language---Common Lisp}.

@anchor{IEEE 2004}
The @acronym{IEEE} and The Open Group. 2001-2004. @cite{The Open Group Base Specifications Issue
6@/ IEEE Std 1003.1, 2004 Edition}.

@node    List of Exercises, List of Figures, References, Top
@unnumbered List of Exercises


@node    List of Figures, Index, List of Exercises, Top
@unnumbered List of Figures


@node    Index,  , List of Figures, Top
@unnumbered Index

@quotation
Any inaccuracies in this index may be explained by the fact@* 
that it has been prepared with the help of a computer. 

---Donald E. Knuth, @cite{Fundamental Algorithms}@* 
(Volume 1 of @cite{The Art of Computer Programming}) 
@end quotation

@sp 1.7

@printindex cp

@bye
